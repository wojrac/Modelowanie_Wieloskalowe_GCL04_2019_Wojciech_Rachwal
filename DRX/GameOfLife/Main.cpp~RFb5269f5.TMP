#include"Cell.h"
#include<memory>
#include<SFML\Graphics.hpp>
#include<SFML\Window.hpp>
#include<boost\filesystem.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/ini_parser.hpp>
#include<filesystem>
#include<vector>
#include<SFML\Graphics.hpp>
#include<SFML\Window.hpp>
using namespace boost::filesystem;
namespace fs= std::experimental::filesystem;
using namespace sf;
int coordinateToNumber(int, int, shared_ptr<Cell>,int,int);
vector<vector<char>> decompress(vector<vector<char>>);
int coordinateToNumber(int coordinateX, int coordinateY, shared_ptr<Cell> arr,int sX,int sY)
{
	
	int i = 0;
	while (!(arr.get()[i].getCoordinateX() == coordinateX && arr.get()[i].getCoordinateY() == coordinateY) && i<sX*sY)
	{
		//cout << "i :" << i;
		i++;
	}
	return  i;
}
vector<string> decompressVec(vector<vector<char>> &vec)
{
	vector<string> vecSTR;
	vector<string> vecSTR2;
	vecSTR.reserve(vec.size());
	int ich,counter;
	int sizeVect;
	vector<int> tmp;
	int cnt = 0;
	int is;
	for (auto const & v : vec)
		vecSTR.emplace_back(v.begin(), v.end());  //vector char[] ->vector string
	for (int i = 0; i < vecSTR.size(); i++)
	{
		sizeVect = vecSTR[i].size();
		for (int j = 0 ; j <sizeVect; j=j++)
		{
			//counter = 0;
			if (isdigit(vecSTR[i][j]) )
			{
				if (j == sizeVect-1)
				{
					vecSTR[i].push_back(vecSTR[i][j]);
					is = stoi(string(1, vecSTR[i][j]));
					for (int l = 0;l < is-1; l++)
					{
						tmp.push_back(i);
						cnt++;
					}
					
				}
				else
				{
					ich = stoi(string(1, vecSTR[i][j]));
					//ich = static_cast<int>(vecSTR[0][j]);

					//cout << "ich " << ich << endl;
					//cout << "vector " << vecSTR[0][j]<<endl;
					for (int k = 0; k < ich; k++)
					{
						//vecSTR[0][j] += vecSTR[0][j + 1];

						vecSTR[i].push_back(vecSTR[i][j + 1]);
						//counter++;
					}
				}
				
				
			}
			else
			{
				//wchodzi i sie nie konczy
				if (j == 0 || !isdigit(vecSTR[i][j - 1]))
				{
					vecSTR[i].push_back(vecSTR[i][j]);
				}
				
				else {
					
				}
				
				
			}
		}
		cout <<"vectsize "<< vecSTR[i].size() << endl;
		for (int l = sizeVect, m = 0; m < vecSTR[i].size(); l++, m++) {
			if (m < vecSTR[i].size() - sizeVect)
				vecSTR[i][m] = vecSTR[i][l];
			else
				vecSTR[i][m] = 0;
		}
		/*for (int l = sizeVect+1 ; l < sizeVect; l++)
			vecSTR[i][l] = 0;*/
	
	}
	/*int sizeVec2;
	for (int i = 0; i < vecSTR.size(); i++)
	{
		
		sizeVec2 = vecSTR[i].size();
		vecSTR[i]
	}*/
	for (int i = 0; i < tmp.size(); i++)
	{
		//cout << "tmp " << tmp[i] << endl;
		vecSTR.insert(vecSTR.begin() + tmp[i]+i+1, "bbbb");
	}
	return vecSTR;


}


int main()
{
	RenderWindow window = { VideoMode{800,600} , "Game of life" };
	window.setFramerateLimit(60);
	
	
	CircleShape circleShape1(10.f);
	circleShape1.setFillColor(Color(100,250,50));
	
	
	vector<string> patternFromFile;
	string iter;
	boost::property_tree::ptree pt;
	fs::path p{ "hardPattern.rle" };
	//fs::path p2{ "hardPattern2.rle" };    do ewentualnego zapisu
	std::ifstream ifs(p);
	//std::ofstream ofs(p2);
	
	while (!ifs.eof())
	{
		ifs >> iter;
		patternFromFile.push_back(iter);
	} //czyli mam w wektorze  caly string z pliku
	/*for (int i = 0; i < patternFromFile.size(); i++)
	{
		cout << patternFromFile[i] << endl;
	}*/
	//przydaloby sie poodzielac te stringi zeby kazda linijka planszy to byl oddzielny element tablicy
	vector<char> dividedByDollar;
	vector<vector<char>> dividedByDollar2;
	string concatenedPatternFromFile=" ";
	for (int i = 0; i < patternFromFile.size(); i++)
	{
		concatenedPatternFromFile += patternFromFile[i];
	}
	cout << concatenedPatternFromFile << endl;
	cout<<"rozmiar :"<<concatenedPatternFromFile.size() << endl;
	int j = 1;
	int counter;
	for (int i = 1; concatenedPatternFromFile[i]; i=i+counter+1)
	{
		
		counter = 0;
		while(concatenedPatternFromFile[j] != '$' && concatenedPatternFromFile[j] != '!' && concatenedPatternFromFile[j])
		{
			
			dividedByDollar.push_back(concatenedPatternFromFile[j]);
			j ++ ;
			
			counter++;
		}
		j++;
		dividedByDollar2.push_back(dividedByDollar);
		dividedByDollar.clear();
	}
	
	
	vector<string> decompressedVector = decompressVec(dividedByDollar2);   //wreszcie to mam!
	for (int i = 0; i < decompressedVector.size(); i++)
	{
		cout << decompressedVector[i] << endl;
	}
	boost::property_tree::ini_parser::read_ini("config.ini", pt);
	
	/*boost::property_tree::ptree::iterator pos = ptjson.begin();
	
	s=ptjson.get<std::string>(pos->second.data());
	cout << "s : " << s << endl;*/
	
	//TABLICE SASIADOW DLA SKRAJNYCH KOMOREK
	// dla rogow zwieksza z 3->5
	Cell neighboursWithLeftTop[5];
	Cell neighboursWithLeftDown[5];
	Cell neighboursWithRightTop[5];
	Cell neighboursWithRightDown[5];
	cout << "START GAME!" << endl;
	string sizeXs, sizeYs,cordXs[5],cordYs[5];
	int sizeX, sizeY,cordX[5],cordY[5],cordX1,cordY1, numberOfCell;
	vector<int> cordXVec;
	vector<int> cordYVec;
	try {
		
		sizeXs = pt.get<std::string>("Section1.sizeX");
		sizeYs = pt.get<std::string>("Section1.sizeY");
		sizeX = atoi(sizeXs.c_str());
		sizeY = atoi(sizeYs.c_str());
		if (sizeX <= 0 || sizeY <=0)
			throw 99;
	}
	catch (int x)
	{
		cout << "cordinates must not be less or equal than 0, ERROR NR: " << x<< endl;
		cout << "it is necesary to change this to 1 " << endl;
		if(sizeX<=0)
		sizeX = 1;
		if(sizeY<=0)
		sizeY = 1;
	}
	shared_ptr<Cell> myBoard(new Cell[sizeX*sizeY],default_delete<Cell[]>());
	 //NEW TECHNOLOGY
	for (int i = 0; i <sizeY; i++)
	{
		for (int j = 0; j < sizeX; j++)
		{
			myBoard.get()[j + sizeX*i].setCellDead();
			myBoard.get()[j+sizeX*i].setCoordinateX(j);
			myBoard.get()[j+sizeX*i].setCoordinateY(i);
		}
	}
	/*for (int i = 0; i < sizeX*sizeY; i++)
	{
		cout << "x"<<i<<" "<<myBoard.get()[i].getCoordinateX()<<endl;
		cout<<"y"<<i<< " "<<myBoard.get()[i].getCoordinateY()<<endl;
	}*/
	//MUSZE JAKOS TO WYPISAC
	//przed setupem
	
	while (window.isOpen())
	{
		
		window.clear(Color::Black);
		Event event;
		while (window.pollEvent(event))
		{

			if (event.type == sf::Event::Closed)
				window.close();
		}
		for (int i = 0, k = sizeY - 1; i < sizeY + 1; i++, k--)
		{
			if (k != -1)
			{
				cout << k % 10;
			}
			for (int j = 0; j < sizeX; j++)
			{

				if (i != (sizeY))
					//cout << "x";
				{
					window.draw(circleShape1);
					circleShape1.setPosition(20*j,0);
				}
				else
				{
					if (j == 0)
						cout << "-";			//TO MOJ PROWIZORYCZNY INTERFEJS GRAFICZNY

					cout << j % 10;
				}

			}
			
			circleShape1.setPosition(0, 20 * i);
		}
		
		//SETUP
		int is;
		//bool flag = false;
		for (int i = 0; i < decompressedVector.size(); i++)
		{
			for (int j = 0; j < decompressedVector[i].size(); j++)
			{
				if (decompressedVector[i][j] == 'o')
				{

					cordXVec.push_back(j);
					cordYVec.push_back(i);
				}
			}
		}
		//bool mainSelector = true;
		//while (mainSelector)
		//{

			/*int decision;
			int choiceWay;
			cordXs[0] = pt.get<std::string>("Section1.cordX1");
			cordYs[0] = pt.get<std::string>("Section1.cordY1");
			cordXs[1] = pt.get<std::string>("Section1.cordX2");
			cordYs[1] = pt.get<std::string>("Section1.cordY2");
			cordXs[2] = pt.get<std::string>("Section1.cordX3");
			cordYs[2] = pt.get<std::string>("Section1.cordY3");
			cordXs[3] = pt.get<std::string>("Section1.cordX4");
			cordYs[3] = pt.get<std::string>("Section1.cordY4");
			cordXs[4] = pt.get<std::string>("Section1.cordX5");
			cordYs[4] = pt.get<std::string>("Section1.cordY5");
			cout << "Do You want use a pattern(glider)(CHOOSE 1) or use copperhead?(CHOOSE 2) or set pattern alone(CHOOSE 3)" << endl;
			cin >> choiceWay;
			switch (choiceWay)
			{
			case 1:
				decision = 1;
				break;
			case 2:
				decision = 2;
				break;
			case 3:
				decision = 3;
				break;
			defalut:
				break;
			}*/
			//bool selector = true;
			//int choice;
			int it = 0;

			/*if (decision == 1)
			{
				while (it < 5)
				{


					cordX[it] = atoi(cordXs[it].c_str());
					cordY[it] = atoi(cordYs[it].c_str());
					numberOfCell = coordinateToNumber(cordX[it], cordY[it], myBoard, sizeX, sizeY);
					myBoard.get()[numberOfCell].setCellAlive();
					if (it == 4)
					{
						system("cls");
						for (int i = sizeY - 1; i >= 0; i--)
						{
							for (int j = 0; j < sizeX; j++)
							{
								if (myBoard.get()[j + sizeX*i].IsAlive())
									//cout << "o";
									window.draw(circleShape1);
								else //cout << "x";
									window.draw(circleShape1);
							}
							cout << endl;
						}
						int enter;
						cout << "lets play , choose any number" << endl;
						cin >> enter;
					}
					it++;
				}
			}*/
			
			
				while (it < cordXVec.size())
				{

					numberOfCell = coordinateToNumber(cordXVec[it] + 20, cordYVec[it] + 20, myBoard, sizeX, sizeY);
					myBoard.get()[numberOfCell].setCellAlive();
					if (it == cordXVec.size() - 1)
					{
						//system("cls");
						for (int i = sizeY - 1; i >= 0; i--)
						{
							for (int j = 0; j < sizeX; j++)
							{
								if (myBoard.get()[j + sizeX*i].IsAlive())
									//cout << "o";
								{
									window.draw(circleShape1);
									circleShape1.setPosition(20 * j, 0);
								}

								else //cout << "x";
								{
									window.draw(circleShape1);
									circleShape1.setPosition(20 * j, 0);
								}
							}
							//cout << endl;
							circleShape1.setPosition(0, 20 * i);
						}
						//int enter;
						//cout << "lets play , choose any number" << endl;
						//cin >> enter;
					}
					it++;
				}
			
			/*else
			{
				while (selector)
				{
					cout << "Give coordinates to make cell alive: " << endl;
					cout << "coordinateX: ";
					cin >> cordX1;
					cout << endl;
					cout << "coordinateY: ";
					cin >> cordY1;
					numberOfCell = coordinateToNumber(cordX1, cordY1, myBoard, sizeX, sizeY);
					//cout << "number of cell: " << numberOfCell << endl;
					myBoard.get()[numberOfCell].setCellAlive();
					for (int i = sizeY - 1; i >= 0; i--)
					{
						for (int j = 0; j < sizeX; j++)
						{
							if (myBoard.get()[j + sizeX*i].IsAlive())
								//cout << "o";
								window.draw(circleShape1);

							else //cout << "x";
								window.draw(circleShape1);
						}
						cout << endl;
					}
					cout << "DO YOU WANT ALIVE ANOTHER CELL? CHOOSE 1. DO YOU HAVE START GAME? CHOOSE 2" << endl;
					cin >> choice;
					if (choice == 2)
					{
						selector = false;
					}
				}*/
				// po setupie



			//}

			int NumberOfCellInRow = sizeX - 2;
			int NumberOfCellInColumn = sizeY - 2;

			unique_ptr<unique_ptr<Cell[]>[]>    neighboursWithTopRow;
			unique_ptr<unique_ptr<Cell[]>[]>    neighboursWithDownRow;
			//5->8
			unique_ptr<unique_ptr<Cell[]>[]>    neighboursWithLeftColumn;
			unique_ptr<unique_ptr<Cell[]>[]>    neighboursWithRightColumn;
			unique_ptr<Cell[]>                   smartPtr1D;
			unique_ptr<Cell[]>                   DownRow1D;
			unique_ptr<Cell[]>					 Left1D;
			unique_ptr<Cell[]>                   Right1D;

			neighboursWithTopRow = make_unique< unique_ptr<Cell[]>[] >(NumberOfCellInRow);
			neighboursWithDownRow = make_unique< unique_ptr<Cell[]>[] >(NumberOfCellInRow);
			neighboursWithLeftColumn = make_unique< unique_ptr<Cell[]>[] >(NumberOfCellInColumn);
			neighboursWithRightColumn = make_unique< unique_ptr<Cell[]>[] >(NumberOfCellInColumn);
			for (int i = 0; i < NumberOfCellInRow; i++)
			{
				smartPtr1D = make_unique<Cell[]>(5);
				DownRow1D = make_unique<Cell[]>(5);

				for (int j = 0; j < 5; j++)
				{
					//smartPtr1D[j] = myBoard.get()[j];
					//dataCounter++;
				}
				neighboursWithTopRow[i] = move(smartPtr1D);
				neighboursWithDownRow[i] = move(DownRow1D);

			}
			for (int i = 0; i < NumberOfCellInColumn; i++)
			{
				Left1D = make_unique<Cell[]>(8);
				Right1D = make_unique<Cell[]>(8);
				neighboursWithLeftColumn[i] = move(Left1D);
				neighboursWithRightColumn[i] = move(Right1D);
			}
			int NumberOfCellInTheMiddle = (sizeX - 2)*(sizeY - 2);
			unique_ptr<unique_ptr<Cell[]>[]>    neighboursMiddle;
			unique_ptr<Cell[]>                   middle1D;
			neighboursMiddle = make_unique< unique_ptr<Cell[]>[] >(NumberOfCellInTheMiddle);
			for (int i = 0; i < NumberOfCellInTheMiddle; i++)
			{
				middle1D = make_unique<Cell[]>(8);

				neighboursMiddle[i] = move(middle1D);
			}
			unique_ptr<int[]> temporaryArray;
			temporaryArray = make_unique<int[]>(NumberOfCellInTheMiddle);
			unique_ptr<int[]> arrayWithSum;
			arrayWithSum = make_unique<int[]>(sizeX*sizeY);
			bool selectorMain = true;
			int rightDownId = sizeX - 1;
			int rightTopId = sizeX*sizeY - 1;
			int leftTopId = rightTopId - sizeX + 1;
			//TU BEDZIE POCZATEK PETLI Z ITERACJAMI
			//while (selectorMain)
			//{
				neighboursWithLeftDown[0] = myBoard.get()[1];
				neighboursWithLeftDown[1] = myBoard.get()[sizeX];
				neighboursWithLeftDown[2] = myBoard.get()[sizeX + 1];
				neighboursWithLeftDown[3] = myBoard.get()[rightDownId];
				neighboursWithLeftDown[4] = myBoard.get()[rightDownId + sizeX];

				//cout << "przed" << endl;
				//int sum = neighboursWithLeftDown[0].IsAlive() + neighboursWithLeftDown[1].IsAlive();
				//cout << "po" << endl;
				//musze wyznaczyc numer prawego dolnego

				neighboursWithRightDown[0] = myBoard.get()[rightDownId - 1];
				neighboursWithRightDown[1] = myBoard.get()[rightDownId + sizeX];
				neighboursWithRightDown[2] = myBoard.get()[rightDownId + sizeX - 1];
				neighboursWithRightDown[3] = myBoard.get()[0];
				neighboursWithRightDown[4] = myBoard.get()[sizeX];

				neighboursWithRightTop[0] = myBoard.get()[rightTopId - 1];
				neighboursWithRightTop[1] = myBoard.get()[rightTopId - sizeX];
				neighboursWithRightTop[2] = myBoard.get()[rightTopId - 1 - sizeX];
				neighboursWithRightTop[3] = myBoard.get()[leftTopId];
				neighboursWithRightTop[4] = myBoard.get()[leftTopId - sizeX];

				neighboursWithLeftTop[0] = myBoard.get()[leftTopId + 1];
				neighboursWithLeftTop[1] = myBoard.get()[leftTopId - sizeX];
				neighboursWithLeftTop[2] = myBoard.get()[leftTopId + 1 - sizeX];
				neighboursWithLeftTop[3] = myBoard.get()[rightTopId];
				neighboursWithLeftTop[4] = myBoard.get()[rightTopId - sizeX];

				//CZAS NA PASY
				//najpierw musze wyznaczyc ilosc komorek w kolumnie


				for (int i = 0; i < NumberOfCellInRow; i++)					// i - i-ta komorka w pasie 
				{
					neighboursWithTopRow[i][0] = myBoard.get()[(leftTopId + i + 1) - 1];
					neighboursWithTopRow[i][1] = myBoard.get()[(leftTopId + i + 1) + 1];
					neighboursWithTopRow[i][2] = myBoard.get()[(leftTopId + i + 1) - sizeX - 1];
					neighboursWithTopRow[i][3] = myBoard.get()[(leftTopId + i + 1) - sizeX];
					neighboursWithTopRow[i][4] = myBoard.get()[(leftTopId + i + 1) - sizeX + 1];

					neighboursWithDownRow[i][0] = myBoard.get()[(i + 1) - 1];
					neighboursWithDownRow[i][1] = myBoard.get()[(i + 1) + 1];
					neighboursWithDownRow[i][2] = myBoard.get()[(i + 1) + sizeX + 1];
					neighboursWithDownRow[i][3] = myBoard.get()[(i + 1) + sizeX];
					neighboursWithDownRow[i][4] = myBoard.get()[(i + 1) + sizeX - 1];
				}  //chyba dziala :)

				for (int i = 0; i < NumberOfCellInColumn; i++)
				{
					neighboursWithLeftColumn[i][0] = myBoard.get()[(sizeX*i + sizeX) + sizeX];
					neighboursWithLeftColumn[i][1] = myBoard.get()[(sizeX*i + sizeX) + sizeX + 1];
					neighboursWithLeftColumn[i][2] = myBoard.get()[(sizeX*i + sizeX) + 1];
					neighboursWithLeftColumn[i][3] = myBoard.get()[(sizeX*i + sizeX) - sizeX + 1];
					neighboursWithLeftColumn[i][4] = myBoard.get()[(sizeX*i + sizeX) - sizeX];
					//nowe
					neighboursWithLeftColumn[i][5] = myBoard.get()[rightDownId + sizeX*i + sizeX];
					neighboursWithLeftColumn[i][6] = myBoard.get()[(rightDownId + sizeX*(i + 1)) + sizeX];
					neighboursWithLeftColumn[i][7] = myBoard.get()[(rightDownId + sizeX*(i + 1)) - sizeX];

					neighboursWithRightColumn[i][0] = myBoard.get()[(rightDownId + sizeX*(i + 1)) + sizeX];
					neighboursWithRightColumn[i][1] = myBoard.get()[(rightDownId + sizeX*(i + 1)) + sizeX - 1];
					neighboursWithRightColumn[i][2] = myBoard.get()[(rightDownId + sizeX*(i + 1)) - 1];
					neighboursWithRightColumn[i][3] = myBoard.get()[(rightDownId + sizeX*(i + 1)) - sizeX - 1];
					neighboursWithRightColumn[i][4] = myBoard.get()[(rightDownId + sizeX*(i + 1)) - sizeX];
					//nowe
					neighboursWithRightColumn[i][5] = myBoard.get()[i*sizeX + sizeX];
					neighboursWithRightColumn[i][6] = myBoard.get()[(sizeX*i + sizeX) + sizeX];
					neighboursWithRightColumn[i][7] = myBoard.get()[(sizeX*i + sizeX) - sizeX];
				}//wyglada ze dziala

				for (int i = 0, l = 0; l < sizeY - 2; i += sizeX, l++)
				{
					for (int j = sizeX + 1 + i, k = 0; k < sizeX - 2; j++, k++)
					{
						temporaryArray[k + l*(sizeX - 2)] = j;
					}
				}
				for (int i = 0; i < NumberOfCellInTheMiddle; i++)
				{

					neighboursMiddle[i][0] = myBoard.get()[temporaryArray[i] - sizeX - 1];
					neighboursMiddle[i][1] = myBoard.get()[temporaryArray[i] - sizeX];
					neighboursMiddle[i][2] = myBoard.get()[temporaryArray[i] - sizeX + 1];
					neighboursMiddle[i][3] = myBoard.get()[temporaryArray[i] + 1];
					neighboursMiddle[i][4] = myBoard.get()[temporaryArray[i] + sizeX + 1];
					neighboursMiddle[i][5] = myBoard.get()[temporaryArray[i] + sizeX];
					neighboursMiddle[i][6] = myBoard.get()[temporaryArray[i] + sizeX - 1];
					neighboursMiddle[i][7] = myBoard.get()[temporaryArray[i] - 1];
				}

				arrayWithSum[0] = neighboursWithLeftDown[0].IsAlive() + neighboursWithLeftDown[1].IsAlive() + neighboursWithLeftDown[2].IsAlive() + neighboursWithLeftDown[3].IsAlive() + neighboursWithLeftDown[4].IsAlive();
				arrayWithSum[rightDownId] = neighboursWithRightDown[0].IsAlive() + neighboursWithRightDown[1].IsAlive() + neighboursWithRightDown[2].IsAlive() + neighboursWithRightDown[3].IsAlive() + neighboursWithRightDown[4].IsAlive();
				arrayWithSum[rightTopId] = neighboursWithRightTop[0].IsAlive() + neighboursWithRightTop[1].IsAlive() + neighboursWithRightTop[2].IsAlive() + neighboursWithRightTop[3].IsAlive() + neighboursWithRightTop[4].IsAlive();
				arrayWithSum[leftTopId] = neighboursWithLeftTop[0].IsAlive() + neighboursWithLeftTop[1].IsAlive() + neighboursWithLeftTop[2].IsAlive() + neighboursWithLeftTop[3].IsAlive() + neighboursWithLeftTop[4].IsAlive();  //oki to chyba dziala
				for (int i = 1, j = 0; j < NumberOfCellInRow; i++, j++)
				{
					arrayWithSum[i] = neighboursWithDownRow[j][0].IsAlive() + neighboursWithDownRow[j][1].IsAlive() + neighboursWithDownRow[j][2].IsAlive() + neighboursWithDownRow[j][3].IsAlive() + neighboursWithDownRow[j][4].IsAlive();
				}
				for (int i = leftTopId + 1, j = 0; j < NumberOfCellInRow; i++, j++)
				{
					arrayWithSum[i] = neighboursWithTopRow[j][0].IsAlive() + neighboursWithTopRow[j][1].IsAlive() + neighboursWithTopRow[j][2].IsAlive() + neighboursWithTopRow[j][3].IsAlive() + neighboursWithTopRow[j][4].IsAlive();
				}
				for (int i = sizeX, j = 0; j < NumberOfCellInColumn; i += sizeX, j++)
				{
					arrayWithSum[i] = neighboursWithLeftColumn[j][0].IsAlive() + neighboursWithLeftColumn[j][1].IsAlive() + neighboursWithLeftColumn[j][2].IsAlive() + neighboursWithLeftColumn[j][3].IsAlive() + neighboursWithLeftColumn[j][4].IsAlive() + neighboursWithLeftColumn[j][5].IsAlive() + neighboursWithLeftColumn[j][6].IsAlive() + neighboursWithLeftColumn[j][7].IsAlive();
				}
				for (int i = rightDownId + sizeX, j = 0; j < NumberOfCellInColumn; i += sizeX, j++)
				{
					arrayWithSum[i] = neighboursWithRightColumn[j][0].IsAlive() + neighboursWithRightColumn[j][1].IsAlive() + neighboursWithRightColumn[j][2].IsAlive() + neighboursWithRightColumn[j][3].IsAlive() + neighboursWithRightColumn[j][4].IsAlive() + neighboursWithRightColumn[j][5].IsAlive() + neighboursWithRightColumn[j][6].IsAlive() + neighboursWithRightColumn[j][7].IsAlive();
				}
				for (int j = 0; j < (sizeX - 2)*(sizeY - 2); j++)
				{
					arrayWithSum[temporaryArray[j]] = neighboursMiddle[j][0].IsAlive() + neighboursMiddle[j][1].IsAlive() + neighboursMiddle[j][2].IsAlive() + neighboursMiddle[j][3].IsAlive() + neighboursMiddle[j][4].IsAlive() + neighboursMiddle[j][5].IsAlive() + neighboursMiddle[j][6].IsAlive() + neighboursMiddle[j][7].IsAlive();
				}
				//TERAZ WARUNKI
				for (int i = 0; i < sizeX*sizeY; i++)
				{
					if (!(myBoard.get()[i].IsAlive()))
					{
						if (arrayWithSum[i] == 3)
						{
							myBoard.get()[i].setCellAlive();
						}
					}
					else
					{
						if (arrayWithSum[i] < 2 || arrayWithSum[i] > 3
							)
						{
							myBoard.get()[i].setCellDead();
						}
					}

				}
				/*for (int i = 0; i < sizeX*sizeY; i++)
				{										do ewentualnego zapisu
					ofs<< myBoard.get()[i].IsAlive();
				}*/

				//system("cls");
				for (int i = sizeY - 1; i >= 0; i--)
				{
					for (int j = 0; j < sizeX; j++)
					{
						if (myBoard.get()[j + sizeX*i].IsAlive())
							//cout << "o";
						{
							window.draw(circleShape1);
							circleShape1.setPosition(20 * j, 20*i);
						}

						else //cout << "x";
						{
							window.draw(circleShape1);
							circleShape1.setPosition(20 * j, 20*i);
						}
					}
					//cout << endl;
					circleShape1.setPosition(0, 20 * i);
				}

				//int choiceMain;
				//cout << "Another turn? CHOOSE 1 , the end? CHOOSE 2 " << endl;
				//cin >> choiceMain;
				//if (choiceMain == 2)
				//{
				//	selectorMain = false;
				//}
			//}
			for (int i = 0; i < sizeX*sizeY; i++)
			{
				myBoard.get()[i].setCellDead();
			}
		//}
		window.display();
		
	}
	
	system("pause");
	
}